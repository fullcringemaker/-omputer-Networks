package main

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"github.com/ethereum/go-ethereum/ethclient"
	"log"
	"math/big"
	"net/http"
	"time"
)

// Константы для подключения к Infura и Firebase
const (
	infuraURL   = "https://mainnet.infura.io/v3/6dd88c2f98b241eb8e15033618275191"
	firebaseURL = "https://etherium-realtime-transactions-default-rtdb.europe-west1.firebasedatabase.app"
)

// Структуры для записи данных о блоке и транзакциях в Firebase
type BlockData struct {
	Number     uint64 `json:"number"`
	Time       uint64 `json:"time"`
	Difficulty uint64 `json:"difficulty"`
	Hash       string `json:"hash"`
	TxCount    int    `json:"txCount"`
}

type TransactionData struct {
	Hash     string `json:"hash"`
	Value    string `json:"value"`
	To       string `json:"to"`
	Gas      uint64 `json:"gas"`
	GasPrice string `json:"gasPrice"`
}

// Функция записи данных блока в Firebase
func writeBlockToFirebase(blockData BlockData) error {
	url := fmt.Sprintf("%s/blocks/%d.json", firebaseURL, blockData.Number)
	bodyBytes, err := json.Marshal(blockData)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("PUT", url, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")

	clientHttp := &http.Client{}
	resp, err := clientHttp.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		return fmt.Errorf("failed to write block data to firebase: status code %d", resp.StatusCode)
	}
	return nil
}

// Функция записи данных транзакций в Firebase
func writeTransactionsToFirebase(blockNumber uint64, txs []TransactionData) error {
	url := fmt.Sprintf("%s/blocks/%d/transactions.json", firebaseURL, blockNumber)
	bodyBytes, err := json.Marshal(txs)
	if err != nil {
		return err
	}

	req, err := http.NewRequest("PUT", url, bytes.NewBuffer(bodyBytes))
	if err != nil {
		return err
	}
	req.Header.Set("Content-Type", "application/json")

	clientHttp := &http.Client{}
	resp, err := clientHttp.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode < 200 || resp.StatusCode > 299 {
		return fmt.Errorf("failed to write transactions data to firebase: status code %d", resp.StatusCode)
	}
	return nil
}

func main() {
	ctx := context.Background()

	// Подключение к Ethereum через Infura
	client, err := ethclient.Dial(infuraURL)
	if err != nil {
		log.Fatalln("Ошибка подключения к Ethereum через Infura:", err)
	}
	defer client.Close()

	// Пример получения последнего блока (из примеров в задании)
	header, err := client.HeaderByNumber(ctx, nil)
	if err != nil {
		log.Fatalln("Ошибка получения заголовка последнего блока:", err)
	}
	fmt.Println("Последний блок в сети (пример из задания):", header.Number.String())

	// Пример получения блока по номеру (из примеров в задании)
	exampleBlockNumber := big.NewInt(15960495)
	blockExample, err := client.BlockByNumber(ctx, exampleBlockNumber)
	if err != nil {
		log.Fatalln("Ошибка получения блока с номером 15960495:", err)
	}
	fmt.Println("Пример данных о блоке 15960495:")
	fmt.Println(blockExample.Number().Uint64())
	fmt.Println(blockExample.Time())
	fmt.Println(blockExample.Difficulty().Uint64())
	fmt.Println(blockExample.Hash().Hex())
	fmt.Println(len(blockExample.Transactions()))

	// Пример получения данных о транзакциях (из примеров в задании)
	fmt.Println("Пример данных транзакций блока 15960495:")
	for _, tx := range blockExample.Transactions() {
		fmt.Println(tx.ChainId())
		fmt.Println(tx.Hash())
		fmt.Println(tx.Value())
		fmt.Println(tx.Cost())      // Суммарные затраты (value + gas*gasPrice)
		fmt.Println(tx.To())
		fmt.Println(tx.Gas())
		fmt.Println(tx.GasPrice())
		// Ограничимся выводом нескольких транзакций для примера
		break
	}

	// Далее логика мониторинга новых блоков и записи их данных в Firebase
	currentBlock := header.Number.Uint64()

	for {
		newHeader, err := client.HeaderByNumber(ctx, nil)
		if err != nil {
			log.Println("Ошибка получения номера последнего блока:", err)
			time.Sleep(15 * time.Second)
			continue
		}
		newLatestBlock := newHeader.Number.Uint64()

		if newLatestBlock > currentBlock {
			for bNum := currentBlock + 1; bNum <= newLatestBlock; bNum++ {
				block, err := client.BlockByNumber(ctx, big.NewInt(int64(bNum)))
				if err != nil {
					log.Println("Ошибка получения блока:", err)
					continue
				}

				blockNumber := block.NumberU64()
				blockTime := block.Time()
				blockDiff := block.Difficulty().Uint64()
				blockHash := block.Hash().Hex()
				txs := block.Transactions()

				bData := BlockData{
					Number:     blockNumber,
					Time:       blockTime,
					Difficulty: blockDiff,
					Hash:       blockHash,
					TxCount:    len(txs),
				}

				// Запись данных блока в Firebase
				if err := writeBlockToFirebase(bData); err != nil {
					log.Println("Ошибка записи данных блока в Firebase:", err)
				} else {
					fmt.Println("Данные блока записаны в Firebase для блока:", bData.Number)
				}

				// Подготовка данных транзакций для записи
				var txsData []TransactionData
				for _, tx := range txs {
					to := ""
					if tx.To() != nil {
						to = tx.To().Hex()
					}
					txData := TransactionData{
						Hash:     tx.Hash().Hex(),
						Value:    tx.Value().String(),
						To:       to,
						Gas:      tx.Gas(),
						GasPrice: tx.GasPrice().String(),
					}
					txsData = append(txsData, txData)
				}

				// Запись транзакций в Firebase
				if err := writeTransactionsToFirebase(blockNumber, txsData); err != nil {
					log.Println("Ошибка записи транзакций в Firebase:", err)
				} else {
					fmt.Println("Данные транзакций записаны в Firebase для блока:", blockNumber)
				}
			}
			currentBlock = newLatestBlock
		}

		// Пауза перед следующим циклом
		time.Sleep(15 * time.Second)
	}
}
